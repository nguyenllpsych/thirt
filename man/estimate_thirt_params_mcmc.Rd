% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimation.R
\name{estimate_thirt_params_mcmc}
\alias{estimate_thirt_params_mcmc}
\title{Estimate parameters with MCMC}
\usage{
estimate_thirt_params_mcmc(
  resp,
  items,
  control = list(),
  initial_params = list(),
  fixed_params = list(),
  op_params = list()
)
}
\arguments{
\item{resp}{a data.frame of length \verb{[n_person x n_block]} with at least three first variables:
variable \code{person} of the format \code{p} for person number \code{p},
variable \code{block} of the format \code{b} for block number \code{b},
variable \code{resp} of the format \code{r} for response number \code{r}
which corresponds to mupp::find_permutation_index().}

\item{items}{a data.frame of length \verb{[total items]} with five variables:
variable \code{item} of the format \code{i} for item number \code{i},
variable \code{block} of the format \code{b} for block number \code{b},
variable \code{dim} of the format \code{d} for dimension number \code{d},
variable \code{key} with -1 for negatively- and 1 for positively-keyed items.}

\item{control}{a list of three parameters to control the MCMC algorithm:
\code{n_iter} for the number of iterations,
\code{n_burnin} for the number of burn-ins,
\code{step_size_sd} for the step size of new parameter generation,
either one value for all 4 parameters,
or a vector of 4 values in the following order:
theta, gamma, lambda, psisq}

\item{initial_params}{a list of initial parameters to start the algorithm,
each parameter needs to be a matrix
named theta, gamma, lambda, or psisq.}

\item{fixed_params}{a list of fixed parameters to be excluded from estimation,
each parameter needs to be a matrix
named theta, gamma, lambda, or psisq.}

\item{op_params}{a list of fixed parameters for operational items,
each parameter needs to be a matrix
named gamma, lambda, or psisq.}
}
\value{
a list of three objects if no operational items are provided:
\code{all_iters} is a list of length \verb{[n_iter]} for parameter estimates for all iterations,
\code{mean_mcmc} is a list of length 4 for mean of four parameters after burn-ins,
\code{sd_mcmc} is a list of length 4 for SD of four parameters after burn-ins.
three additional objects are included if operational items are provided:
\code{all_iters_test} includes all iterations for test items calibration,
\code{mean_mcmc_test} includes parameter estimates for test items calibration,
\code{sd_mcmc_test} includes parameter SD across iterations for test items calibration.
}
\description{
Estimate parameters with MCMC
}
\examples{
\dontrun{
set.seed(202108)

# designs
n_person      <- 100
n_item        <- 3
n_neg         <- 1
n_block       <- 2
n_dim         <- 4
n_iter        <- 1000
n_burnin      <- 20
step_size_sd  <- 0.1

# simulate parameters
params <- simulate_thirt_params(n_person = n_person,
                                n_item   = n_item,
                                n_neg    = n_neg,
                                n_block  = n_block,
                                n_dim    = n_dim)
resp   <- do.call(simulate_thirt_resp, params)
gamma  <- params$gamma$gamma
lambda <- params$items$lambda
psisq  <- params$items$psisq
theta  <- params$persons[, -1]

# operational parameters
op_gamma <- matrix(
  # first pair 1-2 is fixed for each of 2 blocks
  c(0.4, NA, NA,
   -0.9, NA, NA)
  )
op_lambda <- matrix(
  # first 2 items are fixed for each of 2 blocks
  c(-0.65, 0.55, NA,
    0.57, -0.40, NA)
  )
op_psisq <- matrix(
  # first 2 items are fixed for each of 2 blocks
  c(0.89, 0.72, NA,
    0.02, 0.41, NA)
)

# estimation output
start_mcmc <- Sys.time()
output     <- estimate_thirt_params_mcmc(resp  = resp$resp,
                                         items = resp$items,
                                         control = list(n_iter   = n_iter,
                                                        n_burnin = n_burnin,
                                                        step_size_sd = step_size_sd),
                                         op_params = list(gamma = op_gamma,
                                                          lambda = op_lambda,
                                                          psisq = op_psisq)
)
end_mcmc   <- Sys.time()

# correlate estimated and true parameters
diag(cor(theta, output$mean_mcmc$theta))
cor(gamma, output$mean_mcmc_test$gamma)
cor(lambda, output$mean_mcmc_test$lambda)
cor(psisq, output$mean_mcmc_test$psisq)
(time_mcmc <- end_mcmc - start_mcmc)
}

}
